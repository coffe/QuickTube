#!/usr/bin/env python3
import subprocess
import shutil
import sys
import os
import re
import json
import csv
import io
import platform
import urllib.request
from datetime import datetime

# Fixa Windows konsol-kodning f√∂r att visa emojis och gum-border korrekt
# St√§ll in konsolen till UTF-8 (cp65001)
os.system("chcp 65001 > nul")
# Tvinga Python att anv√§nda UTF-8 f√∂r stdout/stderr
sys.stdout.reconfigure(encoding='utf-8')
sys.stderr.reconfigure(encoding='utf-8')

def get_user_bin_dir():
    """Returnera s√∂kv√§gen till anv√§ndarens lokala bin-mapp (Windows)."""
    home = os.path.expanduser("~")
    return os.path.join(os.environ.get("APPDATA", home), "QuickTube", "bin")

def setup_resources():
    """Konfigurera PATH f√∂r att inkludera bin√§rer."""
    paths_to_add = []
    
    # 1. Anv√§ndarens uppdaterade bin√§rer (h√∂gst prio)
    user_bin = get_user_bin_dir()
    # Vi l√§gger till den √§ven om den inte finns √§n, s√• subprocess hittar den om vi skapar den under k√∂rning
    paths_to_add.append(user_bin)
    
    # 2. Inbyggda bin√§rer (PyInstaller)
    if hasattr(sys, '_MEIPASS'):
        # Om vi k√∂rs som en PyInstaller-exe
        bundle_bin = os.path.join(sys._MEIPASS, "bin")
        paths_to_add.append(bundle_bin)
    else:
        # Om vi k√∂rs som script (dev mode)
        dev_bin = os.path.join(os.path.dirname(os.path.abspath(__file__)), "bin")
        if os.path.exists(dev_bin):
            paths_to_add.append(dev_bin)
    
    # L√§gg till i PATH
    if paths_to_add:
        os.environ["PATH"] = os.pathsep.join(paths_to_add) + os.pathsep + os.environ["PATH"]

setup_resources()

# Global inst√§llning
COOKIE_BROWSER = None

def get_ytdlp_base_cmd():
    """Returnera bas-kommando f√∂r yt-dlp inklusive cookies om valt."""
    cmd = ["yt-dlp", "--no-warnings", "--force-overwrites", "--embed-metadata", "--embed-thumbnail"]
    if COOKIE_BROWSER:
        cmd.extend(["--cookies-from-browser", COOKIE_BROWSER])
    return cmd

def select_cookie_browser():
    """V√§lj webbl√§sare f√∂r cookies."""
    global COOKIE_BROWSER
    
    browsers = ["Ingen (Standard)", "chrome", "firefox", "brave", "edge", "safari", "opera", "vivaldi", "chromium"]
    choice = gum_choose(browsers, header="V√§lj webbl√§sare att l√•na cookies fr√•n (l√∂ser ofta 'Bot' fel):")
    
    if choice and choice != "Ingen (Standard)":
        COOKIE_BROWSER = choice
        gum_style(f"Webbl√§sare vald: {COOKIE_BROWSER}", foreground="212")
    else:
        COOKIE_BROWSER = None
        gum_style("Cookies inaktiverade.", foreground="212")

def write_log(msg, console=True):
    """Skriv meddelande till loggfil och valfritt till konsol."""
    try:
        log_path = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), "log.txt")
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Rensa ANSI-koder f√∂r loggfilen (s√• den blir l√§sbar)
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|[[0-?]*[ -/]*[@-~])')
        clean_msg = ansi_escape.sub('', str(msg))
        
        with open(log_path, "a", encoding="utf-8") as f:
            f.write(f"[{timestamp}] {clean_msg}\n")
    except Exception:
        pass # Ignorera loggfel f√∂r att inte krascha appen

    if console:
        print(msg)

# --- Hj√§lpfunktioner f√∂r externa kommandon (GUM wrappers) ---

def run_command(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True):
    """K√∂r ett kommando och returnera resultatet."""
    try:
        # Logga att vi k√∂r ett kommando (men inte till konsol, f√∂r plottrigt)
        write_log(f"K√ñR KOMMANDO: {' '.join(cmd)}", console=False)
        
        # Tvinga UTF-8 kodning f√∂r in/utdata f√∂r att hantera emojis etc.
        result = subprocess.run(
            cmd, 
            stdout=stdout,
            stderr=stderr,
            text=text, 
            encoding='utf-8', 
            errors='replace',
            check=False
        )
        return result
    except FileNotFoundError:
        write_log(f"Kommando ej funnet: {cmd[0]}", console=False)
        return None

def gum_style(text, foreground=None, border=None, padding=None, border_foreground=None):
    """Wrapper f√∂r 'gum style'."""
    cmd = ["gum", "style"]
    if foreground:
        cmd.extend(["--foreground", foreground])
    if border:
        cmd.extend(["--border", border])
    if padding:
        cmd.extend(["--padding", padding])
    if border_foreground:
        cmd.extend(["--border-foreground", border_foreground])
    
    cmd.append(text)
    subprocess.run(cmd)

def gum_input(placeholder, value=""):
    """Wrapper f√∂r 'gum input'."""
    cmd = ["gum", "input", "--placeholder", placeholder]
    if value:
        cmd.extend(["--value", value])
    
    # stderr=None l√•ter gum rita UI:t till terminalen
    res = run_command(cmd, stderr=None)
    return res.stdout.strip() if res else ""

def gum_choose(choices, header=None):
    """Wrapper f√∂r 'gum choose'."""
    if header:
        print("") # Nyrad f√∂r snygghet
        gum_style(header, border="rounded", padding="1 2", border_foreground="240")
    
    cmd = ["gum", "choose"] + choices
    # stderr=None l√•ter gum rita UI:t till terminalen
    res = run_command(cmd, stderr=None)
    return res.stdout.strip() if res else ""

import tempfile

def gum_table(csv_data, header):
    """Wrapper f√∂r 'gum table'."""
    full_data = header + "\n" + csv_data
    
    # Skapa tempor√§r fil f√∂r CSV-data f√∂r att undvika pipe-deadlock p√• Windows
    with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8', suffix='.csv') as tf:
        tf.write(full_data)
        tf_path = tf.name
    
    try:
        # L√§s fr√•n filen ist√§llet f√∂r pipe
        with open(tf_path, 'r', encoding='utf-8') as f:
            # Vi anv√§nder stdin=f s√• gum l√§ser fr√•n filen
            process = subprocess.run(
                ["gum", "table", "-s", ",", "--height", "10"],
                stdin=f,
                stdout=subprocess.PIPE,
                stderr=None, 
                text=True,
                encoding='utf-8' # Viktigt f√∂r Windows
            )
            return process.stdout.strip()
    finally:
        # St√§da upp tempfil
        if os.path.exists(tf_path):
            try:
                os.remove(tf_path)
            except:
                pass

# --- K√§rnfunktioner ---

def check_dependencies():
    missing_deps = []
    # mpv och ffmpeg f√∂rv√§ntas finnas p√• systemet, gum/yt-dlp/svtplay-dl √§r inbakade eller i bin
    dependencies = ["gum", "yt-dlp", "svtplay-dl", "mpv", "ffmpeg"]
    
    for dep in dependencies:
        if not shutil.which(dep):
            missing_deps.append(dep)
    
    if missing_deps:
        gum_style("Fel: F√∂ljande beroenden saknas:", foreground="212")
        for dep in missing_deps:
            print(f"- {dep}")
        gum_style("Installera dem och f√∂rs√∂k igen.", foreground="212")
        sys.exit(1)

def get_clipboard():
    """H√§mta inneh√•ll fr√•n urklipp (Windows/PowerShell)."""
    try:
        # Anv√§nd PowerShell f√∂r att h√§mta urklipp p√• Windows
        cmd = ["powershell", "-command", "Get-Clipboard"]
        res = subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)
        return res.stdout.strip()
    except:
        return ""

def is_valid_url(text):
    """Enkel kontroll om texten ser ut som en relevant URL."""
    patterns = [
        r"https?://(www\.)?youtube\.com/",
        r"https?://(www\.)?youtu\.be/",
        r"https?://(www\.)?svtplay\.se/"
    ]
    for pattern in patterns:
        if re.match(pattern, text):
            return True
    return False

# --- Huvudlogik ---

def handle_svtplay(url):
    header_text = "SVT Play-l√§nk detekterad.\nVad vill du g√∂ra?"
    choices = [
        "Ladda ner (B√§sta kvalitet + Undertexter)",
        "Ladda ner Hela Serien (-A)",
        "Ladda ner Hela Serien (yt-dlp)",
        "Ladda ner Specifika Avsnitt (yt-dlp)",
        "Ladda ner de X SISTA avsnitten (svtplay-dl)",
        "Stream (MPV)",
        "Ladda ner endast ljud"
    ]
    
    action = gum_choose(choices, header=header_text)
    
    if not action: return

    print("") # Spacer
    success = False

    if action == "Ladda ner (B√§sta kvalitet + Undertexter)":
        gum_style("Startar nedladdning fr√•n SVT Play...")
        res = subprocess.run(["svtplay-dl", "-S", "-M", url])
        success = (res.returncode == 0)

    elif action == "Ladda ner Hela Serien (-A)":
        gum_style("Startar nedladdning av hela serien...")
        res = subprocess.run(["svtplay-dl", "-S", "-M", "-A", url])
        success = (res.returncode == 0)

    elif action == "Ladda ner Hela Serien (yt-dlp)":
        gum_style("Startar nedladdning av hela serien med yt-dlp...")
        cmd = get_ytdlp_base_cmd()
        cmd.extend([
            "--embed-subs", "--write-subs", "--sub-langs", "all",
            "-o", "%(series)s/S%(season_number)02dE%(episode_number)02d - %(title)s.%(ext)s",
            url
        ])
        res = subprocess.run(cmd)
        success = (res.returncode == 0)

    elif action == "Ladda ner Specifika Avsnitt (yt-dlp)":
        items = gum_input("Ange avsnitt (t.ex. 1, 2-5, 10)...")
        if items:
            gum_style(f"Laddar ner avsnitt {items} med yt-dlp...")
            cmd = get_ytdlp_base_cmd()
            cmd.extend([
                "--embed-subs", "--write-subs", "--sub-langs", "all",
                "--playlist-items", items,
                "-o", "%(series)s/S%(season_number)02dE%(episode_number)02d - %(title)s.%(ext)s",
                url
            ])
            res = subprocess.run(cmd)
            success = (res.returncode == 0)
        else:
            return

    elif action == "Ladda ner de X SISTA avsnitten (svtplay-dl)":
        count = gum_input("Antal avsnitt fr√•n slutet (t.ex. 5)...")
        if count.isdigit():
            gum_style(f"Laddar ner de sista {count} avsnitten...")
            res = subprocess.run(["svtplay-dl", "-S", "-M", "-A", "--all-last", count, url])
            success = (res.returncode == 0)
        else:
            gum_style("Felaktigt antal angivet.", foreground="196")
            return

    elif action == "Stream (MPV)":
        subprocess.run(["mpv", "--no-terminal", url])
        return "stream" # Signalera att vi streamade

    elif action == "Ladda ner endast ljud":
        gum_style("Laddar ner endast ljud...")
        res = subprocess.run(["svtplay-dl", "--only-audio", url])
        success = (res.returncode == 0)

    # Resultatmeddelande
    print("")
    if success:
        gum_style("‚úî Nedladdning slutf√∂rd.", foreground="212")
    else:
        gum_style("‚ùå Nedladdning misslyckades.", foreground="196")
    
    return "download"

def handle_youtube(url):
    # H√§mta info som JSON (s√§krare √§n bash-parsing)
    info_cmd = ["yt-dlp", "--flat-playlist", "--dump-json", "--no-warnings"]
    if COOKIE_BROWSER: info_cmd.extend(["--cookies-from-browser", COOKIE_BROWSER])
    info_cmd.append(url)
    
    res = run_command(info_cmd)
    
    if not res or res.returncode != 0:
        gum_style("Kunde inte h√§mta information f√∂r URL:en.", foreground="212")
        if res:
            print(f"\n--- DEBUG INFO ---")
            print(f"Kommando: {' '.join(info_cmd)}")
            print(f"Return code: {res.returncode}")
            print(f"Error output:\n{res.stderr}")
            print(f"------------------\n")
        
        if not COOKIE_BROWSER:
            gum_style("Tips: Prova att v√§lja en webbl√§sare f√∂r cookies i huvudmenyn.", foreground="240")
        return

    try:
        # yt-dlp kan returnera flera JSON-objekt separerade med newline f√∂r spellistor
        first_line = res.stdout.strip().split('\n')[0]
        info = json.loads(first_line)
    except json.JSONDecodeError:
        gum_style("Kunde inte tolka videoinformation.", foreground="212")
        return

    title = info.get("title", "Ok√§nd titel")
    is_playlist = info.get("_type") == "playlist" or "list=" in url
    
    formatted_title = f"{title[:57]}..." if len(title) > 60 else title

    if is_playlist:
        header = f"Vad vill du g√∂ra med spellistan:\n{formatted_title}?"
        choices = [
            "Stream Hela Spellistan (Video)", 
            "Stream Hela Spellistan (Ljud)",
            "Ladda ner Hela Spellistan (Video)", 
            "Ladda ner Hela Spellistan (Ljud)"
        ]
        action = gum_choose(choices, header=header)

        if action == "Stream Hela Spellistan (Video)":
            subprocess.run(["mpv", "--no-terminal", url])
            return "stream"
        elif action == "Stream Hela Spellistan (Ljud)":
            subprocess.run(["mpv", "--no-video", url])
            return "stream"
        
        # F√∂r nedladdning
        print("")
        cmd = get_ytdlp_base_cmd()
        
        if action == "Ladda ner Hela Spellistan (Video)":
            gum_style("Startar nedladdning av hela spellistan (video)...")
            cmd.extend([
                "-f", "bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best",
                "--merge-output-format", "mp4",
                "-o", "%(playlist)s/%(playlist_index)02d - %(title)s.%(ext)s",
                url
            ])
        elif action == "Ladda ner Hela Spellistan (Ljud)":
            gum_style("Startar nedladdning av hela spellistan (ljud)...")
            cmd.extend([
                "-f", "bestaudio", "-x", "--audio-format", "opus",
                "-o", "%(playlist)s/%(playlist_index)02d - %(title)s.%(ext)s",
                url
            ])
        
        subprocess.run(cmd)
        gum_style("‚úî Nedladdning av spellista slutf√∂rd.", foreground="212")
        return "download"

    else:
        # Enskild video
        header = f"Vad vill du g√∂ra med:\n{formatted_title}?"
        choices = ["Stream Video (MPV)", "Stream Ljud (MPV)", "Ladda ner video", "Ladda ner ljud"]
        action = gum_choose(choices, header=header)

        if action == "Stream Video (MPV)":
            subprocess.run(["mpv", "--no-terminal", url])
            return "stream"
        elif action == "Stream Ljud (MPV)":
            subprocess.run(["mpv", "--no-video", url])
            return "stream"

        elif action == "Ladda ner ljud":
            print("")
            gum_style("Startar nedladdning av ljud...")
            cmd = get_ytdlp_base_cmd()
            cmd.extend([
                "-f", "bestaudio", "-x", "--audio-format", "opus",
                "-o", "% (title)s.%(ext)s", url
            ])
            subprocess.run(cmd)
            gum_style("‚úî Nedladdning slutf√∂rd.", foreground="212")
            return "download"

        elif action == "Ladda ner video":
            # H√§mta format via JSON ist√§llet f√∂r text-parsing (mycket robustare)
            fmt_cmd = ["yt-dlp", "-J"]
            if COOKIE_BROWSER: fmt_cmd.extend(["--cookies-from-browser", COOKIE_BROWSER])
            fmt_cmd.append(url)
            
            res_fmt = run_command(fmt_cmd)
            if not res_fmt: return
            
            try:
                video_data = json.loads(res_fmt.stdout)
                formats = video_data.get("formats", [])
            except:
                return

            table_rows = []
            has_audio_map = {}
            
            # Gruppera format p√• h√∂jd f√∂r att bara visa ETT val per uppl√∂sning (det b√§sta)
            unique_resolutions = {} # Key: height (int), Value: format_dict

            for f in formats:
                # Filtrera bort ljud-endast och thumbnails etc.
                if f.get("vcodec") == "none": continue
                
                # Vissa format saknar height/width
                height = f.get("height") or 0
                width = f.get("width") or 0
                
                # Hoppa √∂ver ogiltiga uppl√∂sningar
                if height == 0: continue

                # H√§mta attribut f√∂r j√§mf√∂relse
                current_size = f.get("filesize") or f.get("filesize_approx") or 0
                current_tbr = f.get("tbr") or f.get("vbr") or 0
                current_fps = f.get("fps") or 0
                
                if height not in unique_resolutions:
                    unique_resolutions[height] = f
                else:
                    existing = unique_resolutions[height]
                    existing_size = existing.get("filesize") or existing.get("filesize_approx") or 0
                    existing_tbr = existing.get("tbr") or existing.get("vbr") or 0
                    existing_fps = existing.get("fps") or 0
                    
                    replace = False
                    
                    # Prioritera FPS f√∂rst (t.ex. 60fps √∂ver 30fps)
                    if current_fps > existing_fps:
                        replace = True
                    elif current_fps < existing_fps:
                        replace = False
                    else:
                        # Samma FPS, g√• p√• bitrate/storlek
                        if current_size > 0 and existing_size > 0:
                            if current_size > existing_size: replace = True
                        elif current_tbr > 0 and existing_tbr > 0:
                            if current_tbr > existing_tbr: replace = True
                        elif current_size > 0 and existing_size == 0:
                            replace = True # F√∂redra k√§nd storlek
                        elif current_tbr > 0 and existing_tbr == 0:
                             replace = True # F√∂redra k√§nd bitrate
                    
                    if replace:
                        unique_resolutions[height] = f

            # Skapa menylistan fr√•n de unika b√§sta formaten
            for height, f in unique_resolutions.items():
                f_id = f.get("format_id", "N/A")
                width = f.get("width") or 0
                res = f"{width}x{height}"
                fps = f.get("fps") or 0
                ext = f.get("ext", "N/A")
                
                acodec = f.get("acodec", "none")
                has_audio = acodec != "none"
                has_audio_map[f_id] = has_audio
                audio_mark = "JA " if has_audio else "NEJ"

                filesize = f.get("filesize") or f.get("filesize_approx")
                size_str = "N/A"
                if filesize:
                    size_str = f"{filesize / (1024*1024):.1f}MiB"

                # Formatera raden snyggt
                row_str = f"{f_id:<5} | {res:<9} | {fps:<4} | {ext:<4} | üéµ:{audio_mark} | {size_str}"
                
                table_rows.append({'str': row_str, 'height': height, 'fps': fps})

            # Sortera: Prim√§rt p√• h√∂jd (st√∂rst f√∂rst)
            table_rows.sort(key=lambda x: x['height'], reverse=True)
            
            # Extrahera bara str√§ngarna
            choices = [r['str'] for r in table_rows]

            header = "V√§lj kvalitet (ID | Uppl√∂sning | FPS | Filtyp | Ljud | Storlek)"
            # Visa max 15 rader √•t g√•ngen f√∂r √∂versk√•dlighet
            choice = gum_choose(choices, header=header) # gum hanterar scrollning sj√§lv
            
            if not choice:
                print("DEBUG: Inget val gjort.")
                return

            # Extrahera format_code (f√∂rsta delen av str√§ngen innan pipe)
            format_code = choice.split('|')[0].strip()
            print("")
            gum_style("Startar nedladdning av video...")
            
            # Best√§m format-str√§ng baserat p√• om ljud redan finns
            final_format = format_code
            if not has_audio_map.get(format_code, False):
                # Om inget ljud finns, l√§gg till bestaudio
                final_format += "+bestaudio"
            
            # Bygg kommando manuellt f√∂r att kunna ta bort --no-warnings och se mer
            cmd = ["yt-dlp", "--force-overwrites", "--embed-metadata", "--embed-thumbnail"]
            if COOKIE_BROWSER:
                cmd.extend(["--cookies-from-browser", COOKIE_BROWSER])
            
            cmd.extend([
                "-f", final_format, 
                "--merge-output-format", "mp4", 
                "-o", "% (title)s-%(height)sp.%(ext)s",
                url
            ])
            
            print(f"\n--- DEBUG: K√ñR KOMMANDO ---")
            print(f"Format valt: {format_code} (Ljud inkluderat i fil: {has_audio_map.get(format_code, False)})")
            print(f"Final format string: {final_format}")
            print(f"Hela kommandot:\n{' '.join(cmd)}")
            print(f"---------------------------\n")

            # K√∂r utan capture f√∂r att se output direkt i terminalen
            subprocess.run(cmd)
            gum_style("‚úî Nedladdning slutf√∂rd (eller avslutad).", foreground="212")
            return "download"


def update_tools():
    """Ladda ner senaste versionerna av verktygen (Windows-only)."""
    user_bin = get_user_bin_dir()
    
    print("")
    gum_style(f"Verktyg installeras/uppdateras i: {user_bin}", foreground="240")
    
    # Bekr√§fta
    if gum_choose(["Ja, uppdatera", "Avbryt"], header="Vill du ladda ner senaste yt-dlp och svtplay-dl?") != "Ja, uppdatera":
        return

    # Skapa mapp
    try:
        os.makedirs(user_bin, exist_ok=True)
    except OSError as e:
        gum_style(f"Kunde inte skapa mapp: {e}", foreground="196")
        return
    
    # --- YT-DLP ---
    ytdlp_url = "https://github.com/yt-dlp/yt-dlp/releases/latest/download/yt-dlp.exe"
    ytdlp_local = "yt-dlp.exe"
    
    gum_style("Laddar ner senaste yt-dlp...", foreground="212")
    try:
        urllib.request.urlretrieve(ytdlp_url, os.path.join(user_bin, ytdlp_local))
        gum_style("‚úî yt-dlp uppdaterad.", foreground="212")
    except Exception as e:
        gum_style(f"‚ùå Misslyckades uppdatera yt-dlp: {e}", foreground="196")

    # --- SVTPLAY-DL ---
    svt_url = "https://github.com/spaam/svtplay-dl/releases/latest/download/svtplay-dl.exe"
    svt_local = "svtplay-dl.exe"
    
    gum_style("Laddar ner senaste svtplay-dl...", foreground="212")
    try:
        urllib.request.urlretrieve(svt_url, os.path.join(user_bin, svt_local))
        gum_style("‚úî svtplay-dl uppdaterad.", foreground="212")
    except Exception as e:
        gum_style(f"‚ùå Misslyckades uppdatera svtplay-dl: {e}", foreground="196")

    print("")
    gum_style("Klart. Starta om programmet f√∂r att anv√§nda nya versioner.", foreground="212")
    input("Tryck Enter f√∂r att forts√§tta...")


def main():
    check_dependencies()
    last_action = ""

    while True:
        clipboard_content = get_clipboard()
        url_from_clipboard = ""

        # F√∂rifyll bara om senaste √•tg√§rden INTE var stream
        if last_action != "stream":
            cleaned = clipboard_content.strip()
            if is_valid_url(cleaned):
                url_from_clipboard = cleaned
        
        last_action = "" # √Öterst√§ll

        url = gum_input("Klistra in/skriv en URL (l√§mna tomt f√∂r meny)...", value=url_from_clipboard)

        if not url:
            # Om tomt, visa huvudmeny
            choice = gum_choose(["Klistra in l√§nk", "Uppdatera verktyg", "V√§lj webbl√§sare f√∂r cookies", "Avsluta"], header="Huvudmeny")
            
            if choice == "Uppdatera verktyg":
                update_tools()
                continue
            elif choice == "V√§lj webbl√§sare f√∂r cookies":
                select_cookie_browser()
                continue
            elif choice == "Avsluta":
                break
            elif choice == "Klistra in l√§nk":
                continue # Loopa om f√∂r att be om URL igen

        is_svt = "svtplay.se" in url
        
        if is_svt:
            last_action = handle_svtplay(url)
        else:
            last_action = handle_youtube(url)

        print("")
        next_step = gum_choose(["Ny l√§nk", "Uppdatera verktyg", "V√§lj webbl√§sare f√∂r cookies", "Avsluta"])
        
        if next_step == "Uppdatera verktyg":
            update_tools()
        elif next_step == "V√§lj webbl√§sare f√∂r cookies":
            select_cookie_browser()
        elif next_step != "Ny l√§nk":
            break

if __name__ == "__main__":
    try:
        # Starta loggfil (om m√∂jligt) utan att kapa stdout
        try:
            log_path = os.path.join(os.path.dirname(os.path.abspath(sys.argv[0])), "log.txt")
            with open(log_path, "a", encoding="utf-8") as f:
                f.write(f"\n\n--- NY SESSION STARTAD: {datetime.now()} ---\n")
        except:
            pass

        main()
    except KeyboardInterrupt:
        print("\nAvslutar...")
        sys.exit(0)
    except Exception as e:
        write_log(f"KRITISKT FEL: {e}")
        input("Tryck Enter f√∂r att avsluta...")